
-----

# 기본 정렬 알고리즘 마스터하기: 슈도코드와 파이썬 구현

**버블 정렬, 삽입 정렬, 선택 정렬**이라는 세 가지 기본적인 정렬 알고리즘을 슈도코드와 실제 파이썬 코드로 자세히 살펴보겠습니다. 이 세 가지 정렬은 비록 효율성 측면에서는 다른 고급 정렬에 비해 떨어지지만, 정렬의 기본 원리를 이해하는 데 가장 좋은 출발점입니다.

각 정렬이 어떤 아이디어로 작동하는지 슈도코드로 먼저 생각의 흐름을 정리하고, 그 생각을 파이썬 코드로 어떻게 옮기는지 함께 따라가 볼까요?

-----

## 1\. 버블 정렬 (Bubble Sort)

**아이디어:** 인접한 두 요소를 비교해서 정렬 순서에 맞지 않으면 자리를 바꿉니다. 이 과정을 반복하면 가장 큰(또는 작은) 요소가 마치 거품처럼 맨 뒤로(또는 앞으로) 이동합니다. 매 순회마다 가장 큰 요소가 제자리를 찾아가므로, 다음 순회에서는 그 부분을 제외하고 정렬합니다.

### 1.1. 버블 정렬 슈도코드

```pseudocode
FUNCTION BubbleSort(ARRAY arr)
    n = LENGTH of arr # 배열의 길이

    # 배열의 길이 - 1 만큼 반복 (마지막 요소는 이미 정렬되어 있으므로)
    FOR i FROM 0 TO n - 2 DO
        # 현재 패스에서 정렬되지 않은 부분에 대해 반복
        # i가 증가할수록 뒤쪽부터 정렬된 부분이 늘어나므로, 비교 범위는 n - 1 - i 까지 줄어듦
        FOR j FROM 0 TO n - 2 - i DO
            # 현재 요소가 다음 요소보다 크면 (오름차순 기준)
            IF arr[j] > arr[j+1] THEN
                # 두 요소의 위치를 바꿈 (Swap)
                SWAP arr[j] AND arr[j+1]
            END IF
        END FOR
    END FOR

END FUNCTION
```

### 1.2. 버블 정렬 파이썬 코드 설명서

```python
def bubble_sort(arr):
    n = len(arr) # 리스트의 길이

    # 외부 루프: n-1번의 전체 패스(Pass)를 진행합니다.
    # 각 패스마다 가장 큰 요소가 맨 뒤로 '버블링'됩니다.
    for i in range(n - 1):
        # 내부 루프: 현재 패스에서 비교할 범위를 설정합니다.
        # i가 0일 때는 n-1번 비교, i가 1일 때는 n-2번 비교, ...
        # 이미 정렬된 뒷부분은 비교하지 않아도 됩니다.
        for j in range(n - 1 - i):
            # 현재 요소가 다음 요소보다 크면 (오름차순 정렬 기준)
            if arr[j] > arr[j + 1]:
                # 두 요소의 위치를 교환(Swap)합니다.
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr

# 사용 예시
my_list = [64, 34, 25, 12, 22, 11, 90]
print(f"정렬 전: {my_list}")
sorted_list = bubble_sort(my_list)
print(f"버블 정렬 후: {sorted_list}") # 출력: 버블 정렬 후: [11, 12, 22, 25, 34, 64, 90]

my_list_2 = [5, 1, 4, 2, 8]
print(f"정렬 전: {my_list_2}")
sorted_list_2 = bubble_sort(my_list_2)
print(f"버블 정렬 후: {sorted_list_2}") # 출력: 버블 정렬 후: [1, 2, 4, 5, 8]
```

**코드 해설:**

  * `len(arr)`: 리스트의 길이를 얻습니다.
  * **외부 `for` 루프 (`for i in range(n - 1)`):** 전체 리스트를 $N-1$번 순회하며 정렬을 진행합니다. 왜냐하면 마지막 한 개는 자연스럽게 제자리를 찾기 때문입니다. `i`는 이미 정렬된 마지막 요소들의 개수를 나타냅니다.
  * **내부 `for` 루프 (`for j in range(n - 1 - i)`):** 현재 패스에서 비교할 범위입니다. `i`가 증가할수록 (즉, 뒤쪽부터 정렬된 요소가 많아질수록) 비교해야 할 범위가 줄어듭니다.
  * `if arr[j] > arr[j + 1]:`: 인접한 두 요소를 비교합니다. (오름차순이므로 현재 요소가 더 크면)
  * `arr[j], arr[j + 1] = arr[j + 1], arr[j]`: 파이썬에서 두 변수의 값을 교환하는 가장 간결한 방법입니다.

-----

## 2\. 삽입 정렬 (Insertion Sort)

**아이디어:** 손에 든 카드패를 정리하듯이, 데이터를 하나씩 '뽑아서' 이미 정렬된 부분의 올바른 위치에 '삽입'합니다.

### 2.1. 삽입 정렬 슈도코드

```pseudocode
FUNCTION InsertionSort(ARRAY arr)
    n = LENGTH of arr # 배열의 길이

    # 두 번째 요소부터 마지막 요소까지 반복 (첫 번째 요소는 이미 정렬된 것으로 간주)
    FOR i FROM 1 TO n - 1 DO
        key = arr[i] # 현재 삽입할 요소를 'key'로 저장

        # key를 정렬된 부분 (i-1부터 0까지)에 삽입할 위치를 찾음
        # key보다 큰 요소들은 오른쪽으로 한 칸씩 밀어냄
        j = i - 1
        WHILE j >= 0 AND arr[j] > key DO
            arr[j+1] = arr[j] # 현재 요소를 오른쪽으로 한 칸 이동
            j = j - 1         # 비교할 다음 요소로 이동
        END WHILE

        arr[j+1] = key # 올바른 위치에 key 삽입
    END FOR

END FUNCTION
```

### 2.2. 삽입 정렬 파이썬 코드 설명서

```python
def insertion_sort(arr):
    n = len(arr) # 리스트의 길이

    # 두 번째 요소부터 시작하여 마지막 요소까지 순회합니다.
    # (첫 번째 요소는 이미 정렬된 부분으로 간주)
    for i in range(1, n):
        key = arr[i] # 현재 삽입할 요소를 'key' 변수에 저장합니다.

        # 정렬된 부분 (현재 요소보다 왼쪽에 있는 부분)의 인덱스입니다.
        j = i - 1

        # j가 0 이상이고, 정렬된 부분의 요소(arr[j])가 key보다 크면
        # (즉, key가 들어갈 자리를 찾을 때까지)
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j] # arr[j]를 오른쪽으로 한 칸 이동시킵니다.
            j -= 1 # 왼쪽으로 한 칸 이동하여 다음 요소와 비교합니다.

        # while 루프가 끝나면 j+1 위치가 key가 삽입될 올바른 자리입니다.
        arr[j + 1] = key
    return arr

# 사용 예시
my_list = [64, 34, 25, 12, 22, 11, 90]
print(f"정렬 전: {my_list}")
sorted_list = insertion_sort(my_list)
print(f"삽입 정렬 후: {sorted_list}") # 출력: 삽입 정렬 후: [11, 12, 22, 25, 34, 64, 90]

my_list_2 = [5, 1, 4, 2, 8]
print(f"정렬 전: {my_list_2}")
sorted_list_2 = insertion_sort(my_list_2)
print(f"삽입 정렬 후: {sorted_list_2}") # 출력: 삽입 정렬 후: [1, 2, 4, 5, 8]
```

**코드 해설:**

  * **외부 `for` 루프 (`for i in range(1, n)`):** 정렬할 데이터를 두 번째 요소(인덱스 1)부터 시작해서 마지막 요소까지 차례대로 'key'로 설정합니다.
  * `key = arr[i]`: 현재 정렬된 부분에 삽입할 요소를 임시 변수 `key`에 저장합니다.
  * `j = i - 1`: `key`의 바로 왼쪽(이미 정렬된 부분)부터 비교를 시작하기 위한 인덱스입니다.
  * **`while` 루프 (`while j >= 0 and arr[j] > key`):**
      * `j >= 0`: 인덱스가 유효한 범위(리스트의 시작)를 벗어나지 않았는지 확인합니다.
      * `arr[j] > key`: 현재 비교하는 정렬된 부분의 요소가 `key`보다 크면, `key`가 들어갈 자리가 아직 아니므로 해당 요소를 뒤로 한 칸 밀어냅니다.
  * `arr[j + 1] = arr[j]`: `arr[j]`의 요소를 한 칸 뒤로(오른쪽으로) 이동시킵니다.
  * `j -= 1`: 비교할 요소를 왼쪽으로 한 칸 이동시킵니다.
  * `arr[j + 1] = key`: `while` 루프가 끝나면 `j + 1`이 `key`가 들어갈 올바른 위치가 되므로, `key`를 삽입합니다.

-----

## 3\. 선택 정렬 (Selection Sort)

**아이디어:** 전체 데이터에서 가장 작은(또는 큰) 요소를 찾아서 맨 앞(또는 맨 뒤)으로 옮깁니다. 이 과정을 반복하면 앞에서부터(또는 뒤에서부터) 순서대로 정렬됩니다.

### 3.1. 선택 정렬 슈도코드

```pseudocode
FUNCTION SelectionSort(ARRAY arr)
    n = LENGTH of arr # 배열의 길이

    # 배열의 길이 - 1 만큼 반복 (마지막 요소는 이미 정렬되어 있으므로)
    FOR i FROM 0 TO n - 2 DO
        # 현재 정렬되지 않은 부분에서 가장 작은 요소의 인덱스를 찾기 위한 변수
        min_idx = i

        # 정렬되지 않은 나머지 부분에서 가장 작은 요소를 탐색
        FOR j FROM i + 1 TO n - 1 DO
            # 현재까지 찾은 가장 작은 요소 (arr[min_idx])보다 더 작은 요소를 발견하면
            IF arr[j] < arr[min_idx] THEN
                min_idx = j # min_idx를 그 요소의 인덱스로 업데이트
            END IF
        END FOR

        # 가장 작은 요소를 찾았으면, 현재 위치(i)의 요소와 가장 작은 요소(min_idx)의 위치를 바꿈
        SWAP arr[i] AND arr[min_idx]
    END FOR

END FUNCTION
```

### 3.2. 선택 정렬 파이썬 코드 설명서

```python
def selection_sort(arr):
    n = len(arr) # 리스트의 길이

    # 외부 루프: n-1번의 전체 패스(Pass)를 진행합니다.
    # 각 패스마다 현재 정렬되지 않은 부분에서 가장 작은 요소를 찾아 제자리로 보냅니다.
    for i in range(n - 1):
        # 현재 정렬되지 않은 부분 (i부터 끝까지)에서
        # 가장 작은 요소의 인덱스를 저장할 변수입니다.
        # 초기에는 현재 위치(i)를 가장 작은 요소의 인덱스로 가정합니다.
        min_idx = i

        # 내부 루프: i 이후의 모든 요소들을 탐색하여 가장 작은 요소를 찾습니다.
        for j in range(i + 1, n):
            # 현재 탐색 중인 요소(arr[j])가
            # 지금까지 찾은 가장 작은 요소(arr[min_idx])보다 더 작으면
            if arr[j] < arr[min_idx]:
                min_idx = j # min_idx를 새로운 가장 작은 요소의 인덱스로 업데이트합니다.

        # 현재 위치(i)의 요소와 찾은 가장 작은 요소(min_idx)의 위치를 교환(Swap)합니다.
        # 이렇게 하면 가장 작은 요소가 올바른 위치(i)로 이동합니다.
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    return arr

# 사용 예시
my_list = [64, 34, 25, 12, 22, 11, 90]
print(f"정렬 전: {my_list}")
sorted_list = selection_sort(my_list)
print(f"선택 정렬 후: {sorted_list}") # 출력: 선택 정렬 후: [11, 12, 22, 25, 34, 64, 90]

my_list_2 = [5, 1, 4, 2, 8]
print(f"정렬 전: {my_list_2}")
sorted_list_2 = selection_sort(my_list_2)
print(f"선택 정렬 후: {sorted_list_2}") # 출력: 선택 정렬 후: [1, 2, 4, 5, 8]
```

**코드 해설:**

  * **외부 `for` 루프 (`for i in range(n - 1)`):** 정렬할 위치를 하나씩 결정합니다. `i`는 현재 정렬될 요소의 위치를 나타냅니다. 마지막 요소는 자동으로 정렬되므로 `n-1`번만 반복합니다.
  * `min_idx = i`: 현재 패스에서 가장 작은 요소를 찾기 위해, 일단 현재 위치(`i`)의 요소가 가장 작다고 가정합니다.
  * **내부 `for` 루프 (`for j in range(i + 1, n)`):** `i` 다음 위치부터 리스트의 끝까지를 탐색하여 `min_idx`에 저장된 값보다 더 작은 요소를 찾습니다.
  * `if arr[j] < arr[min_idx]:`: 현재 탐색 중인 요소(`arr[j]`)가 `min_idx`에 저장된 요소보다 작으면 `min_idx`를 `j`로 업데이트합니다.
  * `arr[i], arr[min_idx] = arr[min_idx], arr[i]`: 내부 루프가 끝난 후, `min_idx`에는 `i`부터 끝까지의 범위에서 가장 작은 요소의 인덱스가 저장되어 있습니다. 이 가장 작은 요소를 현재 `i` 위치의 요소와 교환하여 `i` 위치에 올바른 정렬된 값을 놓습니다.

-----

## 마치며: 정렬의 기본기를 다지셨나요?

이렇게 버블 정렬, 삽입 정렬, 선택 정렬의 슈도코드와 파이썬 구현을 살펴보았습니다. 이 세 가지 정렬은 모두 $O(N^2)$의 시간 복잡도를 가지므로, 데이터의 양이 많아지면 성능이 크게 저하된다는 공통적인 단점이 있습니다. 하지만 각 정렬이 데이터를 어떤 방식으로 비교하고 교환하는지 이해하는 것은 앞으로 더 효율적인 정렬 알고리즘(예: 퀵 정렬, 병합 정렬)을 배우는 데 중요한 기반이 됩니다.

이제 이 코드들을 직접 타이핑해보고, 리스트의 값을 바꿔가며 어떻게 정렬되는지 눈으로 확인해 보세요. 또한, 이 알고리즘들이 왜 $O(N^2)$의 시간 복잡도를 가지는지 내부 루프와 외부 루프의 관계를 통해 다시 한번 고민해 보는 것도 좋습니다\!

---
