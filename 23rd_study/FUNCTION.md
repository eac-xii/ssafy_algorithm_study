
# 함수는 왜 필요할까요? - '반복되는 작업'을 줄여줘요!

매일 아침 토스트를 만들 때마다 똑같이 '식빵 꺼내기', '토스트기에 넣기', '빵 굽기', '버터 바르기'를 반복한다고 생각해 보세요. 매번 이 모든 과정을 처음부터 끝까지 말하고 실행하려면 정말 번거롭겠죠?

이럴 때 우리는 이렇게 말할 수 있어요. "**토스트 굽기**"

이 '토스트 굽기'라는 말 속에는 위에서 언급한 모든 단계가 포함되어 있습니다. 그리고 우리는 그저 "토스트 굽기"라고만 말하면 됩니다.

프로그래밍에서도 마찬가지예요. 어떤 작업을 여러 번 반복해야 할 때, 그 작업을 하나의 묶음으로 만들어 이름을 붙여 놓으면 아주 편리해집니다. 이 '묶음'이 바로 **함수**예요.

함수를 사용하면 다음과 같은 장점이 있어요.

- **코드 재사용:** 한 번 만들어 놓은 함수는 필요할 때마다 언제든지 다시 사용할 수 있어요.

- **코드 관리 용이:** 복잡한 코드를 작은 단위로 쪼개어 놓으면, 코드를 이해하고 수정하기 훨씬 쉬워집니다.

- **오류 감소:** 반복되는 코드를 복사&붙여넣기 하다 보면 실수가 생기기 쉬운데, 함수를 사용하면 이런 실수를 줄일 수 있어요.

# 함수는 어떻게 만들고 사용할까요? - 나만의 '요리 세리피' 만들기

```
def 함수이름(): # def는 "함수를 정의한다"는 의미입니다.
    # 이 안에 함수가 실행할 코드들을 작성합니다.
    # 들여쓰기(indentation)가 중요해요!
    pass
```

## 예시 1: 간단한 인사말 함수

```
def say_hello(): # 'say_hello'라는 이름의 함수를 정의합니다.
    print("안녕하세요!") # 이 함수가 호출되면 "안녕하세요!"를 출력합니다.
    print("파이썬 함수를 배우고 있어요.") # 이 문장도 함께 출력합니다.

# 함수를 '호출'해서 실행하기
say_hello()
# 출력:
# 안녕하세요!
# 파이썬 함수를 배우고 있어요.
```

---

# 함수에 정보 전달하기 - '재료'를 넣는 것처럼!

## 예시 2: 이름과 함께 인사하는 함수

```
def greet(name): # 'name'이라는 매개변수를 받도록 함수를 정의합니다.
    print(f"안녕하세요, {name}님!") # 전달받은 name을 사용합니다.

# 함수를 호출하면서 '인자' 전달하기
greet("김철수") # '김철수'라는 값을 name에 전달합니다.
# 출력: 안녕하세요, 김철수님!

greet("이영희") # '이영희'라는 값을 name에 전달합니다.
# 출력: 안녕하세요, 이영희님!
```

---

# 함수에서 결과 돌려받기 - '요리 결과물'처럼!

## 예시 3: 두 숫자를 더하는 함수

```
def add_numbers(num1, num2): # num1과 num2 두 개의 매개변수를 받습니다.
    result = num1 + num2 # 두 숫자를 더합니다.
    return result # 더한 결과를 반환합니다. (돌려줍니다)

# 함수를 호출하고 반환된 값을 변수에 저장하기
sum_result = add_numbers(5, 3) # add_numbers 함수가 계산한 결과(8)를 sum_result에 저장합니다.
print(f"두 숫자의 합은: {sum_result}")
# 출력: 두 숫자의 합은: 8

another_sum = add_numbers(10, 20)
print(f"또 다른 합은: {another_sum}")
# 출력: 또 다른 합은: 30

```

---

# 문제 분해 및 체계적인 접근: 복잡한 문제도 쪼개서 해결!

- 1. 큰 문제를 작은 문제로 분할: 
    전체 문제를 한 번에 해결하려고 하기보다, 각 단계를 하나의 독립적인 함수로 만들 수 있습니다.
    예를 들어, '사용자 입력 받기', '데이터 정렬하기', '특정 조건 검색하기', '결과 출력하기' 등 각 단계를 함수로 분리할 수 있습니다.

- 2. 가독성 향상:
    각 함수가 특정 기능만 수행하도록 만들면, 전체 코드를 읽을 때 어떤 부분이 어떤 역할을 하는지 한눈에 파악하기 쉬워집니다.
    이는 마치 잘 정리된 목차처럼 코드를 이해하는 데 도움을 줍니다.

## 예시: 학생들의 성적을 처리하는 알고리즘 문제를 푼다고 가정해 봅시다.

```

# 함수를 사용하지 않을 경우 (복잡해 보일 수 있음)

# scores = [85, 92, 78, 95, 88]
# total_sum = 0
# for score in scores:
#     total_sum += score
# average = total_sum / len(scores)
# print(f"총점: {total_sum}, 평균: {average}")

# 함수를 사용할 경우 (훨씬 깔끔하죠?)

def calculate_sum(data): # 총점 계산 함수
    total = 0
    for item in data:
        total += item
    return total

def calculate_average(data): # 평균 계산 함수
    total = calculate_sum(data) # 다른 함수를 호출하여 재사용!
    return total / len(data) if data else 0 # 데이터가 없을 경우 0 반환

scores = [85, 92, 78, 95, 88]
total_score = calculate_sum(scores)
average_score = calculate_average(scores)

print(f"총점: {total_score}, 평균: {average_score}")

```

---

# 코드 재사용성: DRY (Don't Repeat Yourself) 원칙!

- 1. 코드 중복 방지:
    함수는 특정 작업을 캡슐화(묶어둠)하여 필요할 때마다 호출할 수 있도록 해줍니다.
    이렇게 하면 똑같은 코드를 여러 번 작성할 필요가 없어집니다.

- 2. 유지보수 용이성:
    만약 특정 로직에 버그가 있거나 기능을 변경해야 한다면, 함수로 만들어져 있다면 해당 함수 하나만 수정하면 됩니다.
    코드를 복사해서 붙여넣었다면 모든 복사본을 일일이 찾아 수정해야 하는 재앙이 발생할 거예요!

## 예시: 숫자가 짝수인지 홀수인지 판별하는 로직이 여러 곳에서 필요할 때

```

def is_even(number): # 짝수 판별 함수
    return number % 2 == 0

num1 = 7
num2 = 12
num3 = 25

if is_even(num1):
    print(f"{num1}은 짝수입니다.")
else:
    print(f"{num1}은 홀수입니다.")

if is_even(num2):
    print(f"{num2}은 짝수입니다.")
else:
    print(f"{num2}은 홀수입니다.")

# is_even 함수를 정의해두니, 필요할 때마다 그냥 호출하기만 하면 됩니다!

```

---

## 디버깅 및 테스트 용이성: 문제점을 빠르게 찾고 고칠 수 있어요!

- 1. 문제 영역 축소:
    코드가 함수 단위로 분리되어 있으면, 오류가 발생했을 때 어떤 함수에서 문제가 생겼는지 빠르게 파악할 수 있습니다. 예를 들어, 성적 계산 함수에서 오류가 났다면, 그 함수 내부만 집중적으로 살펴볼 수 있습니다.

- 2. 단위 테스트:
    각 함수가 독립적인 기능을 수행하기 때문에, 함수 하나하나를 따로 테스트하여 올바르게 작동하는지 확인할 수 있습니다. 마치 자동차 부품 하나하나를 테스트하는 것과 같죠.

---

## 추상화 및 모듈화: 복잡성을 숨기고 핵심에 집중!

함수는 '추상화'라는 중요한 개념을 제공합니다. 추상화는 세부적인 복잡성을 숨기고, 우리가 해결하려는 문제의 핵심에 집중할 수 있도록 돕습니다.

- 1. '무엇을' 할 것인지 집중:
    함수를 호출할 때는 그 함수가 '어떻게' 동작하는지 세부적으로 알 필요 없이, '무엇을' 해줄 것인지만 알면 됩니다. calculate_average(scores)를 호출할 때 우리는 내부적으로 합계를 어떻게 구하고 나누는지 알 필요 없이, '아, 평균을 구해주는구나!' 하고 이해할 수 있습니다.

- 2. 협업 효율:
    여러 사람이 함께 프로젝트를 진행할 때, 각자 맡은 함수의 기능만 정확히 알고 있다면 서로의 코드를 이해하는 데 훨씬 용이합니다.

---

# 재귀 호출(Recursion)의 기본: 스스로를 호출하는 마법!

일부 알고리즘 문제(예: 팩토리얼 계산, 피보나치 수열, 트리/그래프 탐색)는 재귀 호출이라는 방식으로 해결하는 것이 매우 효율적입니다.
재귀 호출은 함수가 자기 자신을 호출하는 것을 의미하며, 이를 이해하고 활용하려면 함수에 대한 깊은 이해가 필수적입니다.

## 예시: 팩토리얼 계산 (5! = 5 * 4 * 3 * 2 * 1)

```

def factorial(n):
    if n == 0 or n == 1:
        return 1
    else:
        return n * factorial(n - 1) # 함수가 자기 자신을 다시 호출!

print(factorial(5)) # 출력: 120

```

---

# 결론: 함수는 알고리즘 문제 해결의 필수 도구!

함수는 단순히 코드를 줄이는 기술이 아니라, 문제를 구조적으로 사고하고, 효율적으로 해결하며, 유지보수가 쉬운 코드를 작성하는 데 필수적인 사고방식입니다. 처음에는 함수를 어떻게 나누고 정의해야 할지 막막할 수 있지만, 다양한 알고리즘 문제를 풀면서 자연스럽게 함수를 활용하는 노하우를 익히게 될 거예요.